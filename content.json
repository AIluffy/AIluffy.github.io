{"pages":[{"title":"","text":"404","link":"/404.html"}],"posts":[{"title":"Promise.prototype.finally & Promise.prototype.done小探","text":"Promise 已经像血液一样融入到我们的日常工作中，thenable 无时无刻不在发挥着它的作用。网络上关于 Promise 的文章也是汗牛充栋，人们一遍又一遍的咀嚼着 Promise.prototype.then, Promise.prototype.catch 的作用和功效。 很多时候，我们的执行函数会是 p.then(onFulfilled).catch(onRejected)这种形式， 并不会链接太多操作，这有点像 try 语句。 有时候，我们希望一个操作，无论是否抛出异常都会执行，即不管它进入了 resolve，还是 reject，下一步操作都会执行。比如我们发送请求之前会出现一个 loading 图，当我们请求发送完成之后，不管请求有没有出错，我们都希望关掉这个 loading 图以提升用户体验。过去我们可以这么做： 1234567891011this.loading = truerequest() .then((res) =&gt; { // do something this.loading = false }) .catch(() =&gt; { // log err this.loading = false }) 这种写法一点也不 DRY，显得丑陋。为了让代码稍微好看一点，我们也可以这么写： 123456789101112this.loading = truerequest() .then((res) =&gt; { // do something }) .catch(() =&gt; { // log err }) .then(() =&gt; { this.loading = false }) 这么写虽然让我们舒服了点，但是，总感觉哪里怪怪的，总觉得.then 后面还有.catch。作为类比，我们可以看一下 try 语句的三种声明形式： Try…catch Try…finally Try…catch…finally 那么问题来了，为什么 Promise 没有实现 finally 的写法，用于在任何情况下（不论成功或者失败）执行特定后续操作。这样在语义上，代码显得更加直观与合理。 好消息是，Promise.prototype.finally 已于 2018/01/24 进入 ES8 的 stage4 阶段。半数以上的浏览器也做出了兼容。我们现在就可以尝鲜使用了。 于是上面的例子就变成了这样： 123456789101112this.loading = truerequest() .then((res) =&gt; { // do something }) .catch(() =&gt; { // log err }) .finally(() =&gt; { this.loading = false }) 看起来好像也没有什么区别，但其实使用 Promise.finally(onFinally) 和 Promise.then(onFulfilled, onRejected)还是有以下几点不同： 调用内联函数时，不需要多次声明该函数或为该函数创建一个变量保存它。 由于无法知道 promise 的最终状态，所以 finally 的回调函数中不接收任何参数，它仅用于无论最终结果如何都要执行的情况。 与 Promise.resolve(2).then(() =&gt; {}, () =&gt; {}) （resolved 的结果为 undefined）不同，Promise.resolve(2).finally(() =&gt; {}) resolved 的结果为 2。 同样，Promise.reject(3).then(() =&gt; {}, () =&gt; {}) (resolved 的结果为 undefined), Promise.reject(3).finally(() =&gt; {}) rejected 的结果为 3。 1、2 两点容易理解，至于 3、4，可以通过下面的两个例子进行说明： 123456789Promise.resolve('foo'). finally(() =&gt; 'bar'). then(res =&gt; console.log(res));Promise.reject(new Error('foo')). finally(() =&gt; 'bar'). catch(err =&gt; console.log(err.message));// 最终打印的是‘foo’而不是‘bar'，因为finally()会透传fullfilled的值和rejected错误 如果浏览器没有实现 finally，那么可以实现 polyfill： 1234567891011if (typeof Promise.prototype.finally !== 'function') { Promise.prototype.finally = function(onFinally) { return this.then( /* onFulfilled */ res =&gt; Promise.resolve(onFinally()).then(() =&gt; res), /* onRejected */ err =&gt; Promise.resolve(onFinally()).then(() =&gt; { throw err; }) ); };} 通过该 polyfill，可以更加理解为什么 finally()会透传 fullfilled 的值和 rejected 错误。 Promise.prototype.finally()会返回一个 promise 对象，Promise chain 会延续下去。但是如果我们不想这条 Promise chain 继续执行下去，而想在执行一个操作后关闭 Promise chain。这种时候就需要用到 Promise.prototype.done(). Promise.prototype.done 的使用方法和 then 一样，但是该方法不会返回 Promise 对象。 实现 Promise.prototype.done 的 polyfill 如下： 123456789if (typeof Promise.prototype.done === 'undefined') { Promise.prototype.done = function (onFulfilled, onRejected) { this.then(onFulfilled, onRejected).catch(function (error) { setTimeout(function () { throw error; }, 0); }); };} 可以看到，Promise.prototype.done 和 Promise.prototype.finally 存在两点不同： done 并不返回 promise 对象，也就是说，在 done 之后不能使用 then，catch 等方法组成方法链。 done 中发送的异常会被直接抛给外部，也就是说，其不会进行 Promise 的错误处理（Error Handling） 由于 Promise 的 try-catch 机制，出错的问题可能会被内部消化掉。 如果在调用的时候每次都无遗漏的进行 catch 处理的话当然最好了，但是如果在实现的过程中出现了这个例子中的错误的话，那么进行错误排除的工作也会变得困难。这种错误被内部消化的问题也被称为 unhandled rejection ，从字面上看就是在 Rejected 时没有找到相应处理的意思。 - promise 迷你书 以上便是 Promise.prototype.finally 和 Promise.prototype.done 的介绍和说明，也许实际使用的频率不会很高，但是为了高可读的代码，大家不妨一试。 (ゝ ∀･) 参考 promise 迷你书 proposal-promise-finally using-promise-finally-in-node-js.html MDN","link":"/2019/04/10/Promise.prototype.finally & Promise.prototype.done小探/"},{"title":"VS Code 高性能的秘密 — Dispose Pattern","text":"VS Code 是微软出品的新一代轻量级编辑器，一出道便以简洁大气的界面、卓越的性能、以及灵活的可扩展性吸引了大批的拥趸。 插件化是 VS Code 的精髓，大部分功能比如 command、key binding、context menu 都是通过它对外提供的一套扩展API实现并集成到 Code 中。 VS Code 使用多进程的架构来分别处理编辑器的渲染与执行，每开一个窗口，便会为该窗口创建一个进程执行插件，该进程即为 Extension Host。Extension Host 按需激活插件，同一时间内，插件代码可能被运行多次。 为了保证插件的高效运行，VS Code 使用了 Dispose 模式，大部分插件 API 都实现了 IDisposable 接口，生成的对象则会拥有一个 dispose 函数属性。 123interface IDisposable {truedispose(): void;} Dispose 模式主要用来资源管理，资源比如内存被对象占用，则会通过调用方法来释放，这些方法通常被命名为‘close’，‘dispose’，‘free’，‘release’。一个著名的例子便是 C#，C#通过 Dipose Pattern 来释放不受 CLR(Common Language Runtime)管理的非托管资源。 VS Code 是由 Javascript 实现的，众所周知，Javascript 的内存分配是通过 GC(garbage collector)进行管理，大部分情况下它都是自动执行且对用户不可见的。然而这种自动化的管理方式却存在一个潜在的问题，就是 Javascript 开发者会错误的认为他们不需要再关心内存管理了，从而再无意间书写一些不利于内存回收的代码。 所以，最清楚被分配的内存在未来是否需要使用的还是开发者，但是每次使用完一个对象后就手动的将其销毁，这样的做法即不高效，也不可靠。正因为此，VS Code 使用了 Dispose Pattern 来管理对象销毁。当扩展功能执行时，Extension Host 会在正确的时机调用 dispose 方法，销毁 Code 生成的对象，减少内存使用。比如说，方法‘setStatusBarMessage(value: string)’返回一个‘Disposable’对象，当调用 dispose 方法的时候会移除掉信息对象。 Dispose pattern 的实现如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 第一个重载参数是单个disposable类型function dispose&lt;T extends IDisposable&gt;(disposable: T): T;// 第二个重载参数是多个disposable类型传参数，参数可能为undefined。function dispose&lt;T extends IDisposable&gt;(...disposables: Array&lt;T | undefined&gt;): T[];// 第三个重载参数是一个disposable类型的数组。function dispose&lt;T extends IDisposable&gt;(disposables: T[]): T[];// 第三个重载参数为两种，第一个是disposable类型或disposable数组类型，剩余的为disposable类型。function dispose&lt;T extends IDisposable&gt;(first: T | T[], ...rest: T[]): T | T[] | undefined { // 如果第一个参数是数组，则依次调用传参数的dispose方法 if (Array.isArray(first)) { first.forEach(d =&gt; d &amp;&amp; d.dispose()); // 返回空的数组 return []; } else if (rest.length === 0) { // 如果没有没有剩余参数 if (first) { // 如果存在first // 调用第一个dispose first.dispose(); // 返回first return first; } return undefined; } else { // first不是数组，且rest长度不为0 dispose(first); dispose(rest); // 返回空数组 return []; }}// implement IDisposable 的Disposable 抽象类abstract class Disposable implements IDisposable { // Disposable类的静态对象，用于返回一个包含空的dispose方法的IDisposable对象。dispose被执行了，则表示该对象不再需要了。 // 部分基础API使用了该对象，用于标志资源释放。truestatic None = Object.freeze&lt;IDisposable&gt;({ dispose() { } }); // protected属性toDispose返回protected对象_toDispose, 该对象初始值是一个空的数组。trueprotected _toDispose: IDisposable[] = [];true// 返回IDisposable数组。trueprotected get toDispose(): IDisposable[] { return this._toDispose; } // 设置状态标志，表示该对象是否有被销毁。trueprivate _lifecycle_disposable_isDisposed = false; // 暴露公共方法dispose，执行完后将_lifecycle_disposable_isDisposed状态标志设为true，同时调用lifecycle内的dispose方法处理_toDispose数组，并重新赋值空数组。truepublic dispose(): void {truetruethis._lifecycle_disposable_isDisposed = true;truetruethis._toDispose = dispose(this._toDispose);true} // 内部方法注册实例，若_lifecycle_disposable_isDisposed为true，则表明该方法已经被dispose过，则不能再使用，需dispose掉，否则，推入_toDispose数组。trueprotected _register&lt;T extends IDisposable&gt;(t: T): T {true // 判断这个对象有没有被dispose过truetrueif (this._lifecycle_disposable_isDisposed) {truetruetrueconsole.warn('Registering disposable on object that has already been disposed.');truetruetruet.dispose();truetrue} else {truetruetruethis._toDispose.push(t);truetrue}truetruereturn t;true}} 扩展 API 大部分功能类或功能方法都通过上面的抽象类 Disposable 或接口 IDisposable 实现 dispose 方法。下面的函数示例了一个功能类 DelayedDragHandler 如何实现 dispose 方法，当 HTMLElement 的延迟拖动方法执行完后，其实例对象的 timeout 对象会被及时清除，避免内存占用。 12345678910111213141516171819202122232425262728293031323334/** * A helper that will execute a provided function when the provided HTMLElement receives * dragover event for 800ms. If the drag is aborted before, the callback will not be triggered. */export class DelayedDragHandler extends Disposable {trueprivate timeout: any;trueconstructor(container: HTMLElement, callback: () =&gt; void) {truetruesuper();truetruethis._register(addDisposableListener(container, 'dragover', () =&gt; {truetruetrueif (!this.timeout) {truetruetruetruethis.timeout = setTimeout(() =&gt; {truetruetruetruetruecallback();truetruetruetruetruethis.timeout = null;truetruetruetrue}, 800);truetruetrue}truetrue}));true}trueprivate clearDragTimeout(): void {truetrueif (this.timeout) {truetruetrueclearTimeout(this.timeout);truetruetruethis.timeout = null;truetrue}true}truedispose(): void {truetruesuper.dispose();truetruethis.clearDragTimeout();true}} 引用： Dispose Pattern 实现标准的 Dispose 模式 Memory Management Garbage collection Garbage collection in V8, an illustrated guide API","link":"/2019/03/18/VS Code 高性能的秘密 — Dispose Pattern/"},{"title":"健康是一","text":"今年的互联网有点寒冷，大批的公司裁员，整个互联网从业人员人心惶惶。作为一名小小前端仔，也是时刻处在下岗失业，房贷断供的焦虑之中。也许正是这种焦虑，我开始失眠，先开始十二点半，到一点，再到最近的两点。我的休息时间越来越短，然而夜深人静的时刻，我依然难以入眠。说来也是，这种情况从我工作之后就一直存在，长期性的每天工作到九、十点，对身体的伤害已经开始显现，精神上也开始逐渐的萎靡，而我才二十七八岁！前几日去了爱康做了公司的年度体检，来来回回做了十几个项目，想来也是把身体的大小器官检查了个便。结果出来后，我的咽、牙周、泌尿、胆、甲状腺均存在问题，虽不算严重，却也应当引起重视。 互联网人普遍存在拿命换钱的现象，记得双十一的时候，我去医院看了下咽喉。旁边有一个妹子在看病，医生说年轻人还是少熬点夜，你的这些毛病都是熬夜引起的。然而妹子却很不耐烦的说，没有办法啊，双十一肯定要加班的呀，都是KPI啊。也许，这个行业给了很多家境不好的同学人生逆袭的希望，但同时也把他们拉入了资本吸血的陷阱。君不见晚上十点的网商路，却是滴滴司机聚会的好去处，网易、阿里大楼，灯火通明，时有三三两两疲惫的身躯缓缓的走出大门，默默的驻立在大门两边，等待着三四公里外的司机。而我也是这些人群中的一员，每次走出大门，听着身后一声一声的滴滴刷卡声，我不禁疑惑，这一天究竟干了什么？脑袋已经开始迟钝，身体早已僵硬。 时不时的，小组群里会发一些某某公司的员工猝死的消息，大家都会一阵感慨，纷纷开始叙说自己熬夜的情况，无一不指向任务繁重，加班成瘾。为什么任务会这么多，有多少任务又是真正有意义的呢？一个活动上线六七天，然后永久下线，最终变成一个404，却要耗费七八个人一个多月的辛劳与努力，这些时光最后也成为我们生命中的404，meaningless。 可悲的是，我们这一代人的现状还将继续，继续很久很久。国家老龄化趋势不可逆转，新生儿跌破1500万大关。不出五年，大批的老年人退休，中国正式进入老年化。而要支撑国家的，正是我们这一代人，可悲的一代。也许继续牺牲着健康做着996的工作，春蚕到死丝方尽，蜡炬成灰泪始干。 整个社会的现状难以改变，能做的只有改变自己，是时候放下手机，站起来动一动了。健康是一，是一切的基础，我不想某天坐在工位上，突然意识模糊，跌落在地，任由旁边的人围观自己狼狈的模样，而后成为互联网上有一个话题，别人口中的谈资。生活不是为了别人，是为了自己成为想成为的那个人，而健康，就是让之成真的保障。 以上","link":"/2018/12/28/健康是一/"},{"title":"读《兄弟》后感","text":"这个国庆假很长，连请假带中秋，整整九天。我并没有去游山玩水，只是宅在家里四五天。宅的时间久了，人就容易发燥，这时候，一本书适时的出现在我面前–余华的《兄弟》。 第一次认识余华是看了张艺谋的《活着》，我被富贵跌宕起伏的一生所感染，看完电影是鼻涕眼泪抹了一把又一把。心想这故事拍的也太好了，太有深度了，整个中国近一百年的历史被淋漓尽致的刻画到一个小人物身上。当时我知道了这是改编自余华的同名小说， 于是便巴拉了过来细细的读了起来，看完就一个感受，残忍！作者用波澜不惊的笔调叙说着一个又一个死去的故事，这些故事让起先让我触动，接着让我麻木，然而余华却依然不急不缓的给每一个人盖上棺材。看完之后，我心说，这真是一个冷酷的作家。这，是我第一次认识余华。 《兄弟》，却早于余华被我所接触。还记得初中那年，当时家里订的扬子晚报的文学版块会连载一些文学作品，《兄弟》正是在某个时间段占据了报纸的一隅。第一次看《兄弟》，是被封面两个傻傻的大头所吸引，不知怎的，这张封面很对我的胃口。后来我知道，这两个人一个叫宋钢，一个叫李光头，他们是兄弟。 当我国庆再次翻阅《兄弟》时，当时看书的记忆有些竟然涌了上来。我记得自己当初并没有读完《兄弟》，除了这个，唯一还停留在我记忆深处的是小说中的一个片段，孙伟被剃头。孙伟因为留了一头长发要被红卫兵剃头，在反抗的时候，红卫兵的剃刀割破了孙伟的动脉，那血冲出去三米多高。这一画面深深的深深的印在了我幼小的脑海中，一直挥之不去。我不知道自己有没有被这一段所刺激到，但是后来，阅读《兄弟》的记忆就不再出现了。 当我在回家的车上把《兄弟》的最后一段给读完时，车窗外已是凌晨。我长圩了一口气，也算是了了一桩心事。是的，和很多人的感知一样，兄弟这本书是割裂的，余华把它分为上下部也不无道理。有的人觉得下半部写的不好，人物太过脸谱化，显得整个故事虚假，这点我赞同。整个故事就在刘镇的舞台上发生，荒诞不羁，然而你安能说他不反应现实？类似的故事比比皆是，只不过余华将所有改革开放后发生的丑陋集中到了一起，所以显得不真。 再说上部，这时候我们能站在远处，用望远镜观测那个年代发生的一切。说实话，对于一个没有经历过文革的人，依然能从余华的字里行间感受到那个年代的癫狂，而在这份癫狂之下，宋凡平一家显得如此与众不同。我想每一个看完小说的人，不管对小说本身评价如何，都不会吝啬对宋平凡竖起一个大拇指，并大声说上一句，真是个好汉。他是个当代的英雄，用自己伟岸的身躯守卫着小小的家，他的完美与整个刘镇群众是格格不入的。于是，像任何美好的人，美好的事物一样。宋平凡也难逃被摧残的命运。前一天他像个英雄一样被人民群众高高的捧起，转一天，他就被全镇的人所唾骂，所攻击。每每想到此，我总会记起legal high中古美门那段关于民意的辩论。“真正的恶魔，正是无限膨胀的民意，是坚信自己是善人，对落入阴沟的肮脏野狗进行群殴的“善良的”市民”。讽刺吧，对于人民群众，尖锐的批评家们从不手软，余华也是如此，围绕着李光头一家所发生一切，刘镇的群众，每个人都是参与者。余华将他们的丑恶嘴脸刻画的玲离尽致，任何人，都难逃他的责难。 对于小说的主人翁，宋钢和李光头两兄弟，对于发生在他俩身上截然不同的人生，以及和他们共同的女人林红发生的故事。我只想说，作者，你开心就好，正如其在后记里说的那样，有时候写作就是这样奇妙，从狭窄开始往往写出宽广，从宽广开始反而写出狭窄。至于《兄弟》最后是狭窄了还是宽广了，每个人心中都会评判。 以上。","link":"/2017/10/08/读《兄弟》后感/"},{"title":"离线应用技术之——IndexedDB","text":"想要构建离线应用，除了使用service worker，另一个绕不开的话题便是IndexedDB。 IndexedDB是浏览器端的一个基于键值对存储的事务型数据库。为什么要用它，因为想要做到在离线情况下展示数据，数据的持久化是离线应用绕不过去的一个坎。以前使用的是Web SQL，不过它已经被废弃掉了，所以never mind。什么，你说localstorage？确实有很多人会使用localstorage来存储数据，但是相比IndexedDB，它存在很大的不足，原因有三： localstorage 存储有大小限制，限制5MB，不能存储大量数据，尤其是带有结构的数据。 没有查询语句，没有schema，基本上没有任何有关数据库的操作。每次的写入和写出都要字符串化和对象化，何其麻烦。所以在处理带结构的大型数据上基本毫无扩展性。 最关键的一点是，localstorage的API是同步的，这就意味着它会阻塞DOM操作。并且很多时候，离线应用的数据操作需要在service worker中进行，service worker只接受异步的API，所以相较而言，IndexedDB是更好的选择。 下面这张表摘自张鑫旭的博文，改装了一下，可以快速了解IndexeDB的一些基础特性。 IndexedDB 优点 1. 允许对象的快速索引和搜索，因此在Web应用程序场景中，您可以非常快速地管理数据以及读取/写入数据；2. 由于是NoSQL数据库，因此我们可以根据实际需求设定我们的JavaScript对象和索引；3. 在异步模式下工作，每个事务具有适度的粒状锁。这允许您在JavaScript的事件驱动模块内工作。 不足 如果你的世界观里面只有关系型数据库，恐怕不太容易理解。 位置 包含JavaScript对象和键的存储对象。 查询机制 Cursor APIs，Key Range APIs，应用程序代码 事务 锁可以发生在数据库版本变更事务，或是存储对象“只读”和“读写”事务时候。 事务提交 事务创建是显式的。默认是提交，除非我们调用中止或有一个错误没有被捕获。 也许，上表中说到的一些概念你还不是很懂。嘿，您先别急，先坐下，且听我慢慢给您说。 Q1：什么是NoSQL数据库？A1：非关系型数据库，其中的一大类便是通过键值（key-value）存储数据。IndexedDB便是属于这一类。 Q2：什么是事务？A2：指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。它有以下四点特性： 原子性(Atomicity)：事务中的所有操作作为一个整体提交或回滚。 一致性(Consistemcy)：事物完成时，数据必须是一致的，以保证数据的无损。 隔离性(Isolation)：对数据进行修改的多个事务是彼此隔离的。 持久性(Durability)：事务完成之后，它对于系统的影响是永久的，该修改即使出现系统故障也将一直保留。 Q3：Cursor是干嘛用的？A3：cursor即游标，类似于现实中的游标，一个刻度表示一行数据，游标就是尺子上的一片区域，想要获得数据库一行一行的数据，我们可以遍历这个游标就好了。 前菜上的差不多了，现在进入我们的正餐部分。 如何使用IndexedDB？使用IndexedDB其实还蛮简单的，你只需要做两件事： 创建或打开一个数据库 创建一个Object Store对象仓库（它是IndexedDB存储数据的机制，习惯了关系型数据库的同学可以把它想象成一张表） 遵循上面两步，我们便可以开始愉快的使用IndexedDB了。代码如下： 1234567891011121314151617181920212223242526272829303132333435// 创建或使用一个数据库const request = window.indexedDB.open(\"todos\", 1)// 创建schema, 如果浏览器没有找到todos数据库，则它会创建一个，同时触发upgradeneeded事件。request.onupgradeneeded = event =&gt; { //db代表的是与数据库的连接 const db = event.target.result; //首先检测是否存在我们要创建的Object Store if(!db.objectStoreNames.contains(\"todo-meta\")) { //通过createObjectStore方法创建ObjectStore对象来存储对象 const todoStore = db.createObjectStore('todo-meta', {keyPath: 'id'}); //使用index来检索数据，createIndex方法接受两个参数，一个代表index的name，一个代表要被indexed的属性 todoStore.createIndex('nameIdx', 'name'); } if(!db.objectStoreNames.contains(\"todo-items\")) { // keyPath也可以传递一个数组，来共同组成可以索引 const itemStore = db.createObjectStore( \"todo-items\", { keyPath: [ \"todoId\", \"row\" ] } ); itemStore.createIndex(\"todoIndex\", \"todoId\"); } if(!db.objectStoreNames.contains(\"attachments\")) { // 不传keypath也行，交由数据库自己处理key，适合于一些文件内容的存储。 const fileStore = db.createObjectStore( \"attachments\", { autoIncrement: true } ); } } 好吧，我撒谎了，从代码上看，使用IndexedDB并不是那么简单啊，这还是在我没有考虑兼容性的情况下，而忽略了以下这么一大段代码。 1234567 // In the following line, you should include the prefixes of implementations you want to test.window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB; // DON'T use \"var indexedDB = ...\" if you're not in a function. // Moreover, you may need references to some window.IDB* objects:window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction;window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange; // (Mozilla has never prefixed these objects, so we don't need window.mozIDB*) 来自中外各大名宿的吐槽，IndexedDB的API是出了名的膈应人。就比如说新建一个数据库，为啥我要给它取名叫request而不是idb之类的。事实上，对IndexedDB来说，新建数据库是一个request请求，用MDN的原话是，IndexedDB uses a lot of requests。通过这些请求，它能够获取到相应的DOM事件，从而判断该操作是成功了还是失败了。同时，这些请求也有readyState，result和errorCode等一系列属性。这怎么看都像是一个XMLHTTPRequest对象，简直不能再坑了。 吐槽归吐槽，我们还是认真看一下上一段代码做了什么。在连接数据库后，我们通过createObjectStore方法新建了三个对象仓储，第一个参数即为仓储名，第二个参数即为配置项，包含两个属性：1. keyPath，2. autoIncrement。keyPath用于指定对象的键，如果未指定，则对象的创建使用的是out-of-line keys；指定了，则使用in-line keys。至于什么是out-of-line keys和in-line keys，我们通过一图流来进行详细的说明。 可以这么理解，out-of-line keys即为单独生成的一个key，可能需要我们自己指定。而in-line keys则是指定对象的一个属性作为key值，由数据库自动绑定。 至于autoIncrement属性，可以看成一个key generator，自动生成key值。一般来说，keyPath和autoIncrement属性只要使用一个就够了，如果两个同时使用，表示键名为递增的整数，且对象不得缺少指定属性。 当然，除了使用key存储对象，也可以为对象指定index。就像上面代码中的createIndex做的那样，我们依然通过一图流来说明key和index的区别。 可以看到，两者其实是同一份数据，只是由不同的属性索引，当需要检索某一特定属性的数据时，index格外有用。 下面讲讲如何进行数据库的CRUD操作，毕竟这才是我们真正关心的。 执行IndexedDB的CRUD操作只需要如下五步： 与数据库建立连接 创建一个事务 指明Object Store 在该store上执行操作 清除数据库连接 1. 添加数据12345678910111213141516171819202122232425262728293031const request = window.indexedDB.open(\"todos\", 1);request.onsuccess = () =&gt; { const db = request.result; // db.transaction的第一个参数是一个数组，表明我们希望事务执行操作的ObjectStore列表，通常是只有一个。第二个参数表明事务执行的操作，一般为readonly（只读）和readwrite（读写） const transaction = db.transaction( [ \"todo-meta\", \"todo-items\" ], \"readwrite\" ); // 事务使用的两个store const metaStore = transaction.objectStore(\"todo-meta\"); const itemStore = transaction.objectStore(\"todo-items\"); // 新增数据 metaStore.add( { todoDate: 112342392131, todoAuthor: 'luffy' } ); itemStore.add({ todoId: 1, row: 1, name: 'todo 1', completed: false }); // 清除数据库连接 transaction.oncomplete = () =&gt; { db.close(); }; 2. 更新数据1234567891011121314// ...如上连接数据库，创建事务// 这个操作会通过keypath来更新数据，itemStore的keyPath为属性todoId和row的结合，可以看到上个操作新建的todo item的completeed属性被更新为trueconst itemStore = objectStore.put({ todoId: 1, row: 1, name: 'todo 1', completed: true }); // 当然，objectStore.put也可以接受第二个参数，表明对象的键，一般用于out-of-line key的情况。attachmentStore.put(VALUE, KEY);// ...清除数据库连接 3. 删除数据123456// ...如上连接数据库，创建事务// 大概是最简单的API了，指明我们要删除的key就行了itemStore.delete([ \"123\", \"2\" ]);// ...清除数据库连接 4. 读取数据读取操作有那么点不同，因为它会新建一个request，读取数据在request的回调中。 1234567891011// ...如上连接数据库，创建事务// 通过监听onsuccess来获取数据，通过键名获取指定数据const getRequest = itemStore.get(\"123\");// 也可以通过getAll方法获取全部数据const getAllRequest = itemStore.getAll();getRequest.onsuccess = () =&gt; { // 获取的数据在request的result属性中 console.log(getRequest.result);}; 5. 遍历数据get()和getAll()可以获取单个数据或全部数据，但如果想进行更精细的读取操作，比如读取3-20范围的数据，则需要用到cursor及IDBKeyRange两个对象了。 索引的有用之处，在于可以指定读取数据的范围 IDBKeyRange对象的作用则是生成一个表示范围的Range对象。它的生成方法有四种 lowerBound方法：指定范围的下限。upperBound方法：指定范围的上限。bound方法：指定范围的上下限。only方法：指定范围中只有一个值。 下面的代码直接摘自阮一峰老师的文章，仅供参考 1234567891011121314151617181920212223242526// All keys ≤ x var r1 = IDBKeyRange.upperBound(x);// All keys &lt; x var r2 = IDBKeyRange.upperBound(x, true);// All keys ≥ y var r3 = IDBKeyRange.lowerBound(y);// All keys &gt; y var r4 = IDBKeyRange.lowerBound(y, true);// All keys ≥ x &amp;&amp; ≤ y var r5 = IDBKeyRange.bound(x, y);// All keys &gt; x &amp;&amp;&lt; y var r6 = IDBKeyRange.bound(x, y, true, true);// All keys &gt; x &amp;&amp; ≤ y var r7 = IDBKeyRange.bound(x, y, true, false);// All keys ≥ x &amp;&amp;&lt; y var r8 = IDBKeyRange.bound(x, y, false, true);// The key = z var r9 = IDBKeyRange.only(z); 通过IDBKeyRange，结合cursor，便可以实现在一定范围内读取数据的操作了。 1234567891011121314151617// 想要遍历数据，就要openCursor方法，它在当前对象仓库里面建立一个读取光标（cursor）// 绑定rangevar range = IDBKeyRange.bound('3', '20');const cursor = db.trasaction(['todo-item'], 'readOnly').objectStore('todo-item').openCursor(range);//回调函数接受一个事件对象作为参数，该对象的target.result属性指向当前数据对象。当前数据对象的key和value分别返回键名和键值（即实际存入的数据）。continue方法将光标移到下一个数据对象，如果当前数据对象已经是最后一个数据了，则光标指向null。cursor.onsuccess = function(e) { var res = e.target.result; if(res) { console.log(\"Key\", res.key); console.dir(\"Data\", res.value); res.continue(); }} 结语终于把IndexedDB的API给走了一遍，基本上涵盖了我们日常开发的大部分操作，当然还有一部分API可以直接从MDN上查阅。可以看到，这些API不可谓不繁琐，如果直接使用这些API，估计你们不是累死就是被气死。 正所谓哪里有压迫哪里就有反抗，我们的Jake Archibald大神在官方的基础上封装了一个Promise风格的库–idb，可以方便开发者们按照现代JavaScript的方式使用IndexedDB。这里有一篇文章便是基于这个库来介绍IndexedDB的，写的相当不错。 下面这行代码大概展示了使用idb来写出promise及async风格的代码，来源于medium。 12345678910111213async function getAllData() { let db = await idb.open('db-name', 1) let tx = db.transaction('objectStoreName', 'readonly') let store = tx.objectStore('objectStoreName') // add, clear, count, delete, get, getAll, getAllKeys, getKey, put let allSavedItems = await store.getAll() console.log(allSavedItems) db.close()} 感兴趣的同学也可以看看这个简单的使用idb实现的todoList。 以上，XD。","link":"/2019/04/02/离线应用技术之——IndexedDB/"},{"title":"私聊Javascript的Private","text":"众所周知，Javascript是一门基于原型编程的动态脚本语言，虽然它也支持面向对象的编程范式，但想要做到像传统编程语言那样使用OOP，Javascript依然存在这样那样的不足。 从ES6开始，JS开始支持使用Class来编写类，但是该语法依然不够完善，一个显而易见的缺点就是我们无法使用private关键字定义变量。在其它面向对象的语言中，private修饰的成员或方法只能够在其定义的类中的方法中引用，无法通过该类及派生类的对象访问。 为了实现Javascript中的private，防止数据在运行时被改变，本文总结了五类方法来达成这一目的，接下来将一一介绍 一. 使用命名规则 (_xx)在一个工程中，为了区分代码中的私有成员和公有成员，当我们表示一个成员是私有时，就以下划线开头的命名规则来命名。 123456789101112class Company { constructor(name) { //public this.name = name; //private this._asset = 'computer'; } getAsset() { return this._asset; }} 上面的Company类中，_asset表示私有成员，只能通过调用getAsset方法来获取。然而我们并不能阻止外部直接访问这个变量并修改它。123456const company = new Company('netease');console.log(company.getAsset()); // computerconsole.log(company._asset) // computercompany._asset = 'desk';console.log(company.getAsset()); //desk 可以看到，使用命名规则并不能真正的使变量私有化，更多的是作为一种编码规范，约定了代码中的哪些成员是私有的，使得在后期的代码维护中可以一目了然。在后面介绍的方法中，我们也将使用这种命名规则来表示私有成员。 二. 使用闭包 (closure) 闭包是函数和声明该函数的词法环境的组合 下面的例子展示了如何使用闭包封装私有成员变量。 1234567891011121314151617181920function Employee() { const this$ = {}; class Employee { constructor(name) { this$._name = name; } get name() { return this$._name } } return new Employee(...arguments)};const employee = new Employee('anonymous');console.log(employee.name) // 'anonymous'console.log(employee._name) // undefined 可以看到，外部环境不能直接访问闭包内的变量‘this$’对象内的属性，从而实现Employee对象成员的私有化。然而闭包的缺点也很明显，便是其所封装的变量常驻内存，如果管理不善，有可能会造成内存泄漏。那么除了使用闭包，是否还有其它方案可以实现对象成员的私有化呢？答案是yes，接下来的章节我们将考察如何使用ES6新增的特性实现Private成员变量。 三. 使用WeakMapWeakMap是ES6中新增的数据类型，它有一个很大的特点，就是无法遍历，由于WeakMap的key存储的对象是弱引用，所以它的key是无法枚举的。（如果key是可枚举的话，其列表将会受垃圾回收机制的影响，从而得到不确定的结构）利用WeakMap这一特性，我们可以实现对象的私有成员。 12345678910111213141516171819202122232425const map = new WeakMap();// 用来保存每个对象实例的私有成员const internal = obj =&gt; { if (!map.has(obj)) { map.set(obj, {}); } return map.get(obj);}class Employee { constructor(name) { internal(this)._name = name; } get name() { return internal(this)._name; }}const employee = new Employee('anonymous');console.log(employee.name) // 'anonymous'console.log(employee._name) // undefined 虽然我们无法直接通过Employee实例访问到私有属性_name，但是由于存储私有成员的WeakMap对象暴露在外部，我们依然可以通过修改WeakMap来达到访问并修改employee私有成员的目的。 123map.get(employee)._name = 'boss';console.log(employee.name) // 'boss' 所以为了更进一步的优化，WeakMap往往会结合闭包来实现私有成员。 12345678910111213141516171819202122232425262728function Employee() { const private = new WeakMap(); const internal = obj =&gt; { if (!private.has(obj)) { private.set(obj, {}); } return private.get(obj); }; class Employee { constructor(name) { internal(this)._name = name; } get name() { return internal(this)._name; } } return new Employee(...arguments)}const employee = new Employee('anonymous');console.log(employee.name) // 'anonymous'console.log(employee._name) // undefined 因为WeakMap的每个键对自己所引用对象的引用都是 “弱引用”，所以当没有其他引用和该键引用同一个对象时,这个对象将会被当作垃圾回收。这样，闭包所引起的潜在内存泄漏问题就得到来解决。 四. 使用Symbol同WeakMap一样，Symbol也是ES6新增的基本数据类型。Symbol作为对象属性不可见，意味着无法通过遍历或者JSON.stringify访问到，基于这种特性，我们也可以创建对象的私有属性。 12345678910111213141516const _name = Symbol('name');class Employee{ constructor(name) { this[_name] = name; } get name() { return this[_name]; }}const employee = new Employee('anonymous');console.log(employee.name) // 'anonymous'console.log(employee._name) // undefined 使用Symbol来隐藏数据其实也是一种不错的方案，然而同WeakMap一样，它依然有被访问到并修改的风险。通过调用Object.getOwnPropertySymbols()方法，我们可以访问到这个对象的所有Symbol属性，并对其做出修改。 123for (var symbol of Object.getOwnPropertySymbols(employee)) { console.log(employee[symbol]) // 'anonymous'} 五. 使用ProxyProxy也是ES6新增对象，它的作用就是在目标对象之前架设一层“拦截”。当外界访问该对象，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。 利用这一特性，我们可以按照命名规则，对象的私有属性命名以下划线开头，通过代理属性的get和set方法，拦截外部对对象私有属性的访问，从而实现对象的封装。 首先我们定义一个包含陷阱的占位符对象handler，其中的陷阱便是get和set，通过这两个陷阱来控制属性的读写。 12345678910111213141516const handler = { get: function(target, key) { if (key[0] === '_') { throw new Error('Attempt to access private Property'); } return target[key] }, set: function(target, key, value) { if (key[0] === '_') { throw new Error('Attempt to accsess private Property'); } target[key] = value; }} 上面的两个陷阱代理了get和set，每当要访问对象成员时，都会检测是否私有。 123456789101112131415161718class Employee{ constructor(name) { this._name = name; } get name() { return this._name; }}const employee = new Proxy(new Employee('anonymous'), handler);console.log(employee.name); // 'anonymous'console.log(employee._name); // Error: Attempt to access private Propertyemployee._name = 'boss'; // Error: Attempt to access private Propertyconsole.log(square.area) // 100console.log(square instanceof Shape) 当尝试用JSON.stringify序列化employee对象时，因为会访问到私有属性，所以会报错。 1234JSON.stringify(employee) //Error: Attempt to access private Property//at Object.get (fawicagejo.js:4:13)//at JSON.stringify (&lt;anonymous&gt;) 参考MDN 如果一个被序列化的对象拥有 toJSON 方法，那么该 toJSON 方法就会覆盖该对象默认的序列化行为：不是那个对象被序列化，而是调用 toJSON 方法后的返回值会被序列化 所以需要改写get陷阱。 1234567891011121314151617get: function(target, key) { if (key[0] === '_') { throw new Error('Attempt to access private property'); } else if (key === 'toJSON') { const obj = {}; for (const key in target) { if (key[0] !== '_') { obj[key] = target[key]; } } return () =&gt; obj; } return target[key];} 改写完后，再通过JSON.stringify()便能够正常序列化对象了。 不过以上方法依然存在一个问题，就是使用迭代，我们依然可以访问到对象的私有属性。 12 但是我们依然可以通过迭代的形式依然能遍历到私有属性名，比如：1234for (let key in employee) { console.log(key)}// \"_name\" 这个时候，我们需要使用getOwnPropertyDescriptor陷阱，将私有属性的属性描述符中的enumerable设置为false。 123456789getOwnPropertyDescriptor(target, key) { const desc = Object.getOwnPropertyDescriptor(target, key); if (key[0] === '_') { desc.enumerable = false; } return desc;} 完整代码如下 12345678910111213141516171819202122232425262728293031323334353637const handler = { get: function(target, key) { if (key[0] === '_') { throw new Error('Attempt to access private property'); } else if (key === 'toJSON') { const obj = {}; for (const key in target) { if (key[0] !== '_') { obj[key] = target[key]; } } return () =&gt; obj; } return target[key]; }, set: function(target, key, value) { if (key[0] === '_') { throw new Error('Attempt to accsess private Property'); } target[key] = value; }, getOwnPropertyDescriptor(target, key) { const desc = Object.getOwnPropertyDescriptor(target, key); if (key[0] === '_') { desc.enumerable = false; } return desc; }}const employee = new Proxy(new Employee('anonymous'), handler); 新的(#)符号以上的努力都是在Javascript 新的private特性出来所做的尝试，难免繁琐。 ES2018最新的Privatet特性已经进入了https://github.com/tc39/proposals stage3, 我们可以一睹芳容 12345678910111213141516class Employee { #name; constructor(name) { this.#name = name; } get name() { return this.#name; }}const employee = new Employee('anonymous');console.log(employee.name) // 'anonymous'console.log(employee.#name) // undefined 使用#来描述私有成员，使得Javascript也能像其他高级语言一样实现封装了。 结语随着新的特性不断涌现，可以看到Javascript是越趋完善，开发者能够体验越来越丰富的功能以提升开发效率。但是我们依然要感谢前人为了实现这些尚未出现的特性所做出的努力，吃水不忘挖井人。 以上 引用 private-variables-in-javascript javascript-private-class-fields oop-privacy-levels private-class-members-in-es6-a-complete-guide javascripts-new-private-class-fields js-classes-got-an-upgrade proposal-class-fields private-data-in-javascript-4-ways-using-stamps","link":"/2019/03/06/私聊Javascript的Private/"}],"tags":[{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"技术","slug":"技术","link":"/tags/技术/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"design pattern","slug":"design-pattern","link":"/tags/design-pattern/"},{"name":"随笔","slug":"随笔","link":"/tags/随笔/"},{"name":"思考","slug":"思考","link":"/tags/思考/"},{"name":"语法","slug":"语法","link":"/tags/语法/"}],"categories":[]}